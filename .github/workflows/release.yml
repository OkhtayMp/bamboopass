name: Build & Release (multi-platform)

on:
  push:
    tags:
      # Release tags only (e.g. v0.0.1)
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to build (e.g. v0.0.4). Required for workflow_dispatch."
        required: true
        type: string

# Avoid two tag builds racing for the same repo/release.
concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

permissions:
  contents: write

env:
  PYTHON_VERSION: "3.10"
  APP_NAME: "BambooPass"
  ENTRYPOINT: "bamboopass_entry.py"

jobs:
  build:
    name: Build ${{ matrix.target }}
    runs-on: ${{ matrix.runner }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - target: windows-x64
            runner: windows-2022
            ext: ".exe"
          - target: linux-x64
            runner: ubuntu-22.04
            ext: ""
          - target: linux-arm64
            runner: ubuntu-22.04-arm
            ext: ""
          - target: macos-intel
            runner: macos-13
            ext: ""
          - target: macos-arm64
            runner: macos-14
            ext: ""

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # On tag push: github.ref is refs/tags/vX.Y.Z
          # On workflow_dispatch: inputs.tag is vX.Y.Z
          ref: ${{ (github.event_name == 'workflow_dispatch' && inputs.tag) || github.ref }}
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: pip


      - name: "macOS: ensure OpenSSL dylibs visible for Nuitka"
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euxo pipefail

          # Nuitka's dependency scan can fail if CPython's _hashlib expects libssl/libcrypto
          # under a Homebrew path that doesn't exist on the current runner.
          brew list openssl@3 >/dev/null 2>&1 || brew install openssl@3
          PREFIX="$(brew --prefix openssl@3)"

          HASHLIB="$(python - <<'PY2'
          import _hashlib
          print(_hashlib.__file__)
          PY2
          )"
          echo "Using _hashlib at: $HASHLIB"

          expected_ssl="$(otool -L "$HASHLIB" | awk '/libssl\./{print $1; exit}' || true)"
          expected_crypto="$(otool -L "$HASHLIB" | awk '/libcrypto\./{print $1; exit}' || true)"
          echo "Expected libssl:   $expected_ssl"
          echo "Expected libcrypto:$expected_crypto"

          for p in "$expected_ssl" "$expected_crypto"; do
            [ -z "$p" ] && continue
            if [ -e "$p" ]; then
              echo "OK: $p exists"
              continue
            fi

            base="$(basename "$p")"
            src="$PREFIX/lib/$base"

            if [ ! -e "$src" ]; then
              echo "ERROR: source dylib not found: $src"
              ls -la "$PREFIX/lib" || true
              exit 1
            fi

            sudo mkdir -p "$(dirname "$p")"
            sudo rm -f "$p" || true
            sudo ln -sfn "$src" "$p"
            ls -la "$p"
          done

      - name: Resolve TAG / VERSION
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG="${{ inputs.tag }}"
          else
            TAG="${{ github.ref_name }}"
          fi
          VERSION="${TAG#v}"

          echo "TAG=$TAG" >> "$GITHUB_ENV"
          echo "VERSION=$VERSION" >> "$GITHUB_ENV"

          echo "Resolved TAG=$TAG VERSION=$VERSION"

      - name: Inject version into source (no sed)
        shell: bash
        run: |
          python - <<'PY'
          import os, re
          from pathlib import Path

          tag = os.environ["TAG"]
          version = os.environ["VERSION"]

          # Runtime version used by the app
          bv = Path("bamboopass/_build_version.py")
          bv.write_text(f'__version__ = "{version}"\n', encoding="utf-8")

          # Optional: make package metadata match (helps importlib.metadata)
          pyproject = Path("pyproject.toml")
          if pyproject.exists():
              txt = pyproject.read_text(encoding="utf-8")
              new_txt, n = re.subn(
                  r'(?m)^version\s*=\s*"[^"]+"',
                  f'version = "{version}"',
                  txt,
                  count=1,
              )
              if n:
                  pyproject.write_text(new_txt, encoding="utf-8")
              else:
                  print("WARN: Could not find version field in pyproject.toml")

          print(f"Injected VERSION={version} (from TAG={tag})")
          PY

      - name: Install build dependencies
        shell: bash
        run: |
          python -m pip install --upgrade pip
          # zstandard is required for Nuitka onefile compression
          pip install nuitka zstandard PySide6 platformdirs
          pip install -e .

      - name: Build (Nuitka onefile)
        shell: bash
        run: |
          python -m nuitka \
            --mode=onefile \
            --enable-plugin=pyside6 \
            --assume-yes-for-downloads \
            --output-dir=dist \
            "${ENTRYPOINT}"

      - name: Prepare release files
        shell: bash
        run: |
          mkdir -p release

          # Nuitka onefile output is usually:
          #  - dist/<entry>.exe (Windows)
          #  - dist/<entry>.bin (Linux/macOS)
          #  - sometimes dist/<entry> (depending on options)
          if [ -f "dist/bamboopass_entry.exe" ]; then
            BIN_PATH="dist/bamboopass_entry.exe"
          elif [ -f "dist/bamboopass_entry.bin" ]; then
            BIN_PATH="dist/bamboopass_entry.bin"
          elif [ -f "dist/bamboopass_entry" ]; then
            BIN_PATH="dist/bamboopass_entry"
          else
            echo "ERROR: Build output not found in dist/"
            ls -la dist || true
            exit 1
          fi

          OUT_LATEST="${APP_NAME}-${{ matrix.target }}${{ matrix.ext }}"
          OUT_VERSIONED="${APP_NAME}-${TAG}-${{ matrix.target }}${{ matrix.ext }}"

          cp "$BIN_PATH" "release/${OUT_LATEST}"
          cp "$BIN_PATH" "release/${OUT_VERSIONED}"

          # Make sure it's executable on Unix-y runners
          if [ "${{ matrix.ext }}" = "" ]; then
            chmod +x "release/${OUT_LATEST}" "release/${OUT_VERSIONED}" || true
          fi
          # Per-target checksum file (cross-platform, uses Python)
          python - <<'PY'
          import hashlib
          from pathlib import Path

          target = "${{ matrix.target }}"
          files = [
              Path("release/${OUT_LATEST}"),
              Path("release/${OUT_VERSIONED}"),
          ]
          out = Path(f"release/SHA256SUMS-{target}.txt")

          def sha256(path: Path) -> str:
              h = hashlib.sha256()
              with path.open('rb') as f:
                  for chunk in iter(lambda: f.read(1024 * 1024), b''):
                      h.update(chunk)
              return h.hexdigest()

          with out.open('w', encoding='utf-8') as fp:
              for f in files:
                  fp.write(f"{sha256(f)}  {f.name}\n")

          print(f"Wrote {out}")
          PY

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.target }}
          path: release/*
          if-no-files-found: error

  publish:
    name: Publish GitHub Release
    needs: build
    runs-on: ubuntu-22.04
    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release
          merge-multiple: true

      - name: Resolve TAG for publishing
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG="${{ inputs.tag }}"
          else
            TAG="${{ github.ref_name }}"
          fi
          echo "TAG=$TAG" >> "$GITHUB_ENV"
          echo "Publishing assets to tag: $TAG"

      - name: Create or update GitHub Release + upload assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ env.TAG }}
          name: ${{ env.TAG }}
          make_latest: true
          generate_release_notes: true
          files: release/*
          overwrite_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Optional quality-of-life: keep main showing the latest released version.
  # If your main branch is protected, this may fail; release publishing will still succeed.
  sync_main_version:
    name: Sync version back to main (optional)
    needs: publish
    runs-on: ubuntu-22.04
    continue-on-error: true
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Write VERSION + package version files
        shell: bash
        run: |
          set -euxo pipefail
          VERSION="${GITHUB_REF#refs/tags/}"
          VERSION_NO_V="${VERSION#v}"
          echo "$VERSION" > VERSION
          export VERSION_NO_V
          python - <<'PY'
          from pathlib import Path
          import os
          v = os.environ["VERSION_NO_V"]
          Path("bamboopass/_build_version.py").write_text(f"__version__ = '{v}'\n")
          # Keep pyproject version aligned too (optional).
          import re
          p = Path("pyproject.toml")
          txt = p.read_text(encoding="utf-8")
          txt2 = re.sub(r'(?m)^version\s*=\s*"[^"]+"\s*$', f'version = "{v}"', txt)
          p.write_text(txt2, encoding="utf-8")
          PY

      - name: Commit + push (if changed)
        shell: bash
        run: |
          set -euxo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add VERSION bamboopass/_build_version.py pyproject.toml
          if git diff --cached --quiet; then
            echo "No version changes to commit."
            exit 0
          fi
          git commit -m "chore: bump version to ${GITHUB_REF#refs/tags/}"
          git push origin main
